use std::str::FromStr;

//säger att vi ska använda allt (*) ur ast.rs modulen
use crate::ast::*;

grammar;

//----CommentFix----
match {
    // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"\s*" => { }, 
    // Skip `// comments`
    r"//[^\n\r]*" => { }, 
    // Skip `/* comments */`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },  
    _
}

//------REG------
pub Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

pub Id: String = {
    r"([a-z]|[A-Z]|_)([a-z]|[A-Z]|[0-9]|_)*" => String::from_str(<>).unwrap(),
};

pub FuncIdent: String = {
    r"([a-z]|[A-Z]|_)([a-z]|[A-Z]|[0-9]|_)*\(" => String::from_str(<>).unwrap(),
};

pub Bool: bool = {
    "true" => true,
    "false" => false,
};

//-----Expressions-----
pub Exprs: Box<Exprs> = {
    NotOp Expr => Box::new(Exprs::NotOp(<>)), // For Not(Expression)
    Expr,
};

pub Expr: Box<Exprs> = {
    Expr LogOp Factor => Box::new(Exprs::Op(<>)),
    Expr RelOp Factor => Box::new(Exprs::Op(<>)),
    Expr ExpOp Factor => Box::new(Exprs::Op(<>)),
    Factor,
};

pub Factor: Box<Exprs> = {
    Factor FacOp Term => Box::new(Exprs::Op(<>)),
    Term,
};

pub Term: Box<Exprs> = { 
    Bool => Box::new(Exprs::Boolean(<>)),
    Num => Box::new(Exprs::Number(<>)),
    Id => Box::new(Exprs::Id(<>)),
    FunctionCall,
    "(" <Exprs> ")",
};

//----Operands----

NotOp: Op = {
    "!" => Op::Not,
};

FacOp: Op = {
    "*" => Op::Mul,
    "/" => Op::Div,
};

ExpOp: Op = {
    "+" => Op::Add,
    "-" => Op::Sub,
};

LogOp: Op = {
    "&&" => Op::And,
    "||" => Op::Or,
};

RelOp: Op = {
    "==" => Op::Eq,
    "!=" => Op::Neq,
    ">" => Op::Gtr,
    "<" => Op::Lss,
    ">=" => Op::Geq,
    "<=" => Op::Leq,
};

Type: Type = {
    "bool" => Type::Bool,
    "i32" => Type::I32,
    "()" => Type::Unit,
};

pub Stmt: Box<Statement> = {
    //Exprs => Box::new(Statement::Exprs(<>)),
    Let,
    Cond,
    While,
    Assign,
    Return,
    Function,
    
};

pub Stmts: Box<Statement> = {
    <vec_s: Stmt> ";"* => vec_s,
}

Let: Box<Statement> = {
    "let" <opmut: "mut"?> <id:Id> <atype:(":" <Type>)?> <opexp:("=" <Exprs>)?> => Box::new(Statement::Let(opmut.is_some(),id, atype, opexp)),
};

//------Conditions------
Cond: Box<Statement> = {
    "if" <exp: Exprs> <block:Block> <opcond:NextCond?> => Box::new(Statement::Cond(AllCond::If,Some(exp),block,opcond)),
};

NextCond: Box<Statement> = {
    ElseIf,
    Else,
};

ElseIf: Box<Statement> = {
    "else if" <exp:Exprs> <block:Block> <opcond:NextCond?> => Box::new(Statement::Cond(AllCond::ElseIf,Some(exp), block, opcond)),
};

Else: Box<Statement> = {
    "else" <block:Block> => Box::new(Statement::Cond(AllCond::Else,None,block,None)),
};

Block: Box<Statement> = {
    "{" <st: Stmts*> "}" => Box::new(Statement::Block(st))
};

While: Box<Statement> = {
    "while" <exp:Exprs> <block:Block> => Box::new(Statement::While(exp,block))
};

Assign: Box<Statement> = {
    <id:Id> "=" <exp:Exprs> => Box::new(Statement::Assign(id,exp))
};

Return: Box<Statement> = {
    <Exprs> => Box::new(Statement::Return(<>)) 
};

// -----Functions----
Function: Box<Statement> = {
    "fn" <id:Id> "(" <arg:FuncMacro> ")" <typ:("->" <Type>)?> <block:Block> => Box::new(Statement::Function(id, arg,typ,block)), //frickin args
    "fn" <id:Id> "()" <typ:("->" <Type>)?> <block:Block> => Box::new(Statement::Function(id,vec![],typ,block)), //no args
};

FuncMacro = FuncArgSep<FuncArg>;

FuncArgSep<arg>: Vec<arg> = {
    <d:(<arg> ",")*> <ext:arg?> => match ext {
        Some(ext) => {
            let mut d = d;
            d.push(ext);
            d
        },
        None => d,
    }
};

FuncArg: Box<Statement> = {
    <id:Id> ":" <typ:Type> => Box::new(Statement::FuncArg(id,typ)),
};

FunctionCall: Box<Exprs> = { //Ful-lösning med FuncIdent
     <id:FuncIdent> <mac:CallMacro> ")" => Box::new(Exprs::FunctionCall(id,mac))
};
CallMacro = FuncArgSep<Exprs>;
